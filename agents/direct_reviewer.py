import os
import sys
sys.path.append(os.getcwd())

from llms.llms import helper
from datetime import datetime
from pathlib import Path
from typing import Tuple
import json

from pydantic import BaseModel, Field
from colorama import Fore

class DirectReviewerInput(BaseModel):
    original_task_instruction: str = Field(..., description="Original task instruction provided by the user")
    layout_json_str: str = Field(..., description="JSON string of the layout generated by the direct planner")
    image_paths: list[Path] = Field(..., description="Paths to the rendered images of the layout from different axes (x, y, z)")
    session_id: str | None = Field(None, description="Session ID for the review process, if not provided a new one will be generated")
    provider: str = Field("google", description="LLM provider to use for the query")
    model: str = Field("gemini-2.5-flash-lite", description="LLM model to use for the query")
    temperature: float = Field(0, description="Temperature for the LLM response generation")

class DirectReviewerOutput(BaseModel):
    updated_layout_json_str: str = Field(..., description="Updated layout JSON after review")
    satisfactory: bool = Field(..., description="Indicates if the layout is satisfactory or not")
    session_id: str = Field(..., description="Session ID for the review process")


# we supply a manual history with the final layout JSON as assistant response.
_prompt = """
Your layout JSON has been successfully executed and the scene has been rendered in the attached image renderings. Please think step-by-step to identify any layout issues such as:

1. Objects positioned incorrectly or unrealistically
2. Overlapping objects that shouldn't overlap
3. Objects floating in air when they should be on surfaces
4. Poor spatial relationships between objects
5. Objects oriented incorrectly
6. Missing objects or objects placed outside the scene bounds
7. Scale issues (objects too large or too small)

If the layout needs to be updated, please provide the corrected JSON layout in full in a single markdown code block, ensuring that it follows the same structure:
```json
{
    "asset_name": {
        "location": [x, y, z],
        "min": [min_x, min_y, min_z],
        "max": [max_x, max_y, max_z],
        "orientation": [pitch, yaw, roll]
    },
    ...
}
```

If no problems are found and the layout is satisfactory, simply include only a boolean field "satisfactory" set to true in the JSON (do not include this field if you decide to update the layout):
```json
{
    "satisfactory": true
}
```
"""

def review(input_data: DirectReviewerInput) -> DirectReviewerOutput:
    """Reviews the rendered layout images and provides updated JSON layout if improvements are needed."""
    # Create the query prompt with the original task and layout context
    history = [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": input_data.original_task_instruction
                }
            ]
        },
        {
            "role": "assistant",
            "content": f"```json\n{input_data.layout_json_str}\n```"
        }
    ]
    
    # Generate session ID if not provided
    session_id = input_data.session_id or f"direct_reviewer-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    # Convert Path objects to strings for image paths
    image_path_strings = [str(path.resolve()) for path in input_data.image_paths]
    
    # Query the LLM with the rendered images
    response = helper.query(
        provider=input_data.provider,
        model=input_data.model,
        user_prompt=_prompt,
        history_messages=history,
        image_paths=image_path_strings,
        save_path=session_id,
        temperature=input_data.temperature,
    )
    
    # Extract updated layout JSON from the response
    updated_layout_json, satisfactory = extract_updated_layout_json(response)
    
    return DirectReviewerOutput(
        updated_layout_json_str=updated_layout_json,  # note: when satisfactory, this should be discarded
        satisfactory=satisfactory,
        session_id=session_id
    )

def extract_updated_layout_json(response: str) -> Tuple[str, bool]:
    """Extracts the updated layout JSON from the LLM response, also checks for layout satisfaction."""
    try:
        extracted_json = helper.extract_code_block(response, 'json')
        
        # Check if the response indicates satisfaction
        try:
            parsed_json = json.loads(extracted_json)
            if isinstance(parsed_json, dict) and parsed_json.get("satisfactory") is True:
                return extracted_json, True
            else:
                return extracted_json, False
        except json.JSONDecodeError:
            print(Fore.RED + "Warning: Could not parse JSON from LLM response for Direct Reviewer" + Fore.RESET)
            return extracted_json, False
            # TODO: if problems, change it to return None and check above, then return previous input to not mess up the pipeline
    except Exception as e:
        # check for the phrase "layout is good" or "satisfactory" in the response
        print(f"Warning: Could not extract JSON block from LLM response: {e}")
        if "layout is good" in response or "satisfactory" in response.lower():
            return '{"satisfactory": true}', True
        else:
            print("Using full response as JSON (this might not work)...")
            return response, False

if __name__ == '__main__':
    # Example usage
    from test_data.examples import example_direct_planner_query, example_render_output, example_layout
    import json
    
    input_data = DirectReviewerInput(
        original_task_instruction=example_direct_planner_query,
        layout_json_str=json.dumps(example_layout, indent=4),
        image_paths=example_render_output.rendered_images,
        provider="ollama",
        model="gemma3",
        temperature=0
    )
    output = review(input_data)
    from rich import print
    print(output.model_dump())