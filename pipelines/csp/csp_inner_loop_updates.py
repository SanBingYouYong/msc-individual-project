import sys
import os
sys.path.append(os.getcwd())

from agents import csp_3reviewer
from agents.decomposer import DecomposerOutput
from pipelines.common.prep_scene import ScenePrepOutput
from pipelines.csp.layout_verification import LayoutVerificationInput, LayoutVerificationOutput, layout_verification
from pipelines.common.create_and_render import CreateAndRenderInput, CreateAndRenderOutput, create_and_render
from llms.llms import helper
from pipelines.common.utils import save_pydantic_model_as_pkl

from pydantic import BaseModel, Field
from typing import List, Optional
from pathlib import Path
from colorama import Fore
import json
from yaspin import yaspin


class InnerLoopUpdateInput(BaseModel):
    original_task_instruction: str = Field(..., description="Original task instruction for the scene synthesis")
    last_code: str = Field(..., description="Last scoring code generated by the coder")
    last_rendered_images: List[Path] = Field(..., description="Paths to the rendered images of the layout from different axes (x, y, z)")
    decomposer_output: DecomposerOutput = Field(..., description="Output from the decomposer containing asset list and descriptions")
    scene_prep_output: ScenePrepOutput = Field(..., description="Output from the scene preparation pipeline containing generated model files")
    iteration: int = Field(..., description="Current iteration number of the inner loop; only determines file names it saves: update<i>")
    update_folder: Path = Field(..., description="Path to the job folder where the scene will be processed; expected: <job_folder>/update<i>")
    provider: str = Field("google", description="LLM provider to use for the query")
    model: str = Field("gemini-2.5-flash-lite", description="LLM model to use for the query")
    temperature: float = Field(0, description="Temperature for the LLM response generation")
    layout_verify_iters: int = Field(3, description="Maximum number of iterations for layout verification")
    code_fix_iters: int = Field(3, description="Maximum number of iterations for EACH error fixing during code execution")

class InnerLoopUpdateOutput(BaseModel):
    reviewer_output: csp_3reviewer.ReviewerOutput = Field(..., description="Output from the reviewer containing updated code and layout satisfaction status")
    layout_verification_output: Optional[LayoutVerificationOutput] = Field(None, description="Output from the layout verification process (optional, as reviewer might indicate previous layout is satisfactory)")
    scene_output: Optional[CreateAndRenderOutput] = Field(None, description="Output from the scene creation and rendering process (optional, as reviewer might indicate previous layout is satisfactory)")

def inner_loop_update(input_data: InnerLoopUpdateInput) -> InnerLoopUpdateOutput:
    """
    1. Calls the reviewer agent to review last iteration's result
    2. If reviewer indicates satisfactory, return.
    3. Otherwise, obtain the updated code from reviewer and run the layout verification, scene creation, and rendering pipelines.
    4. Return the outputs of the reviewer and the subsequent pipelines.
    """
    # Ensure the job folder exists
    input_data.update_folder.mkdir(parents=True, exist_ok=True)
    # create a subfolder for pipeline input outputs
    stage_folder = input_data.update_folder / f"stage_update{input_data.iteration}"
    stage_folder.mkdir(parents=True, exist_ok=True)
    staged_files: List[Path] = []

    with yaspin(text=f"Inner Loop Update {input_data.iteration}: Reviewer...", color="green", timer=True) as spinner:
        reviewer_input = csp_3reviewer.ReviewerInput(
            original_task_instruction=input_data.original_task_instruction,
            code_executed=input_data.last_code,
            image_paths=input_data.last_rendered_images,
            provider=input_data.provider,
            model=input_data.model,
            temperature=input_data.temperature
        )
        reviewer_output = csp_3reviewer.review(reviewer_input)
        staged_files.append(save_pydantic_model_as_pkl(reviewer_output, stage_folder / "reviewer_output.pkl"))
        
        if reviewer_output.satisfactory:
            spinner.ok("✔ Layout Satisfactory")
            return InnerLoopUpdateOutput(
                reviewer_output=reviewer_output,
                layout_verification_output=None,
                scene_output=None
            )
        
        with open(input_data.update_folder / f"code.py", "w") as f:
            f.write(reviewer_output.updated_code)
        spinner.ok("✔")

    with yaspin(text=f"Inner Loop Update {input_data.iteration}: Layout Verification...", color="green", timer=True) as spinner:
        context_provider_history = helper.load_history(reviewer_output.session_id, as_history_messages=True)
        original_task_instruction = context_provider_history[0]['content'][0]['text']
        layout_verification_input = LayoutVerificationInput(
            code=reviewer_output.updated_code,
            original_task_instruction=original_task_instruction,
            decomposer_output=input_data.decomposer_output,
            working_dir=input_data.update_folder / "temp",
            max_iterations=input_data.layout_verify_iters,
            error_fixing_max_iter=input_data.code_fix_iters,
            provider=input_data.provider,
            model=input_data.model,
            temperature=input_data.temperature
        )
        layout_verification_output = layout_verification(layout_verification_input)
        staged_files.append(save_pydantic_model_as_pkl(layout_verification_output, stage_folder / "layout_verification_output.pkl"))
        spinner.ok("✔")
    
    if not layout_verification_output.is_success:
        print(Fore.RED + "Layout Verification Failed." + Fore.RESET)
        return InnerLoopUpdateOutput(
            reviewer_output=reviewer_output,
            layout_verification_output=layout_verification_output,
            scene_output=None
        )
    
    # save the final code to a py file
    final_code = layout_verification_output.final_code
    with open(input_data.update_folder / f"code.py", "w") as f:
        f.write(final_code)
    print(f"{Fore.GREEN}Final code saved to {input_data.update_folder / 'code.py'}{Fore.RESET}")
    # save verified layout to a json file
    if not layout_verification_output.verified_layout:
        raise RuntimeError("!!!No verified layout returned after passing the code execution and layout verification.")
    layout_path = input_data.update_folder / "layout.json"
    with open(layout_path, "w") as f:
        json.dump(layout_verification_output.verified_layout, f, indent=4)
    print(f"{Fore.GREEN}Layout JSON saved to {layout_path}{Fore.RESET}")
    
    with yaspin(text=f"Inner Loop Update {input_data.iteration}: Creating and Rendering scene according to layout...", color="green", timer=True) as spinner:
        create_and_render_input = CreateAndRenderInput(
            layout_path=layout_path,
            scene_prep_output=input_data.scene_prep_output,
            output_blend_path=input_data.update_folder / "scene.blend",
            render_folder=input_data.update_folder / "renders",
            image_prefix=f"update{input_data.iteration}_render"
        )
        create_and_render_output = create_and_render(create_and_render_input)
        staged_files.append(save_pydantic_model_as_pkl(create_and_render_output, stage_folder / "create_and_render_output.pkl"))
        spinner.ok("✔")
    
    update_output = InnerLoopUpdateOutput(
        reviewer_output=reviewer_output,
        layout_verification_output=layout_verification_output,
        scene_output=create_and_render_output
    )

    # remove the stage folder and save the final big output
    final_output_path = input_data.update_folder / f"inner_loop_update_output_{input_data.iteration}.pkl"
    save_pydantic_model_as_pkl(update_output, final_output_path)
    # remove staged pkls
    for staged_file in staged_files:
        if staged_file.exists():
            staged_file.unlink()
    try:
        stage_folder.rmdir()
    except OSError:
        print(f"Warning: Could not remove stage folder {stage_folder}. It might not be empty or does not exist.")

    print(f"{Fore.GREEN}Inner Loop Update {input_data.iteration} completed. Output saved to {final_output_path}{Fore.RESET}")

    return update_output

class TemperatureIncreaseSchedule:
    """Generator to yield temperature values for each iteration."""
    def __init__(self):
        self.temperatures = [0.3, 0.6, 1.2, 1.5]  # after 1.5, hopefully it will have enough randomness to try different solutions
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index < len(self.temperatures):
            temp = self.temperatures[self.index]
            self.index += 1
            return temp
        else:
            return self.temperatures[-1]  # return the last temperature if all have been used

class UpdatesInput(BaseModel):
    # for initializing first update
    original_task_instruction: str = Field(..., description="Original task instruction for the scene synthesis; expected: original coder query sent, with prompt template applied")
    last_code: str = Field(..., description="Last scoring code generated by the coder")
    last_rendered_images: List[Path] = Field(..., description="Paths to the rendered images of the layout from different axes (x, y, z)")
    # constants across updates
    decomposer_output: DecomposerOutput = Field(..., description="Output from the decomposer containing asset list and descriptions")
    scene_prep_output: ScenePrepOutput = Field(..., description="Output from the scene preparation pipeline containing generated model files")
    # update setting
    job_folder: Path = Field(..., description="Path to the job folder where all update subfolders will be created")
    max_iterations: int = Field(3, description="Maximum number of iterations for the inner loop updates")
    starting_index: int = Field(1, description="Starting index for the update iterations (default: 1)")
    # laosanyang
    provider: str = Field("google", description="LLM provider to use for the query")
    model: str = Field("gemini-2.5-flash-lite", description="LLM model to use for the query")
    temperature: float = Field(0, description="Temperature for the LLM response generation")
    layout_verify_iters: int = Field(3, description="Maximum number of iterations for layout verification")
    code_fix_iters: int = Field(3, description="Maximum number of iterations for error fixing during code execution")

class UpdatesOutput(BaseModel):
    final_output: Optional[InnerLoopUpdateOutput] = Field(None, description="Final output of the inner loop updates, if any updates were run; when None, fall back on input results")
    updates: List[InnerLoopUpdateOutput] = Field([], description="List of all inner loop update outputs")

def updates(updates_input: UpdatesInput) -> UpdatesOutput:
    """
    Runs the inner loop updates for the given input.
    In general, 
    - if the input layout is deemed satisfactory by the first update's reviewer, we return an early-terminated signal
    - if an iteration of update output is deemed satisfactory by the subsequent update's reviewer, we return that satisfactory update output and indicate early-stopping
    - if no iterations are satisfactory (in which case the last update will also aim to provide an updated layout), we return the last successful update output with verified layout
    - when no updates were successful, we will have to use the input
    So, in return, we return None when initial result is good or we have done nothing so have to use initial results
    At each step, check the update output first for satisfactory boolean, and then check for layout verification output's is_success boolean.
    Supports resuming or additional updates; just read last update's code and prepare image paths for the input model; to continue based on update 3, use starting_index=4 and max_iter as usual (in max_iter=2 case updates 4 and 5 will be run)
    """
    updates_list: List[InnerLoopUpdateOutput] = []
    temp_gen = None
    
    # Initialize variables for tracking current state
    current_code = updates_input.last_code
    current_rendered_images = updates_input.last_rendered_images
    last_successful_output = None
    
    print(f"{Fore.CYAN}Starting inner loop updates with max iterations: {updates_input.max_iterations}, starting from index: {updates_input.starting_index}{Fore.RESET}")
    
    for i in range(updates_input.max_iterations):
        iteration = updates_input.starting_index + i
        update_folder = updates_input.job_folder / f"update{iteration}"
        
        # if last update failed verification, we need to retry with an increased temperature
        if updates_list and not updates_list[-1].layout_verification_output.is_success:
            # Get temperature for this iteration - only increase temperature when retrying
            if temp_gen:
                try:
                    current_temp = next(temp_gen)
                except StopIteration:
                    current_temp = 1.5
            else:
                print(f"{Fore.YELLOW}No temperature generator initialized, using last temperature 1.5 for retry.{Fore.RESET}")
                current_temp = 1.5
        else:
            # just use the base temperature
            current_temp = updates_input.temperature
            # reset the temperature generator for the next iteration
            temp_gen = TemperatureIncreaseSchedule()
            
        print(f"{Fore.CYAN}Running update iteration {iteration} with temperature {current_temp}{Fore.RESET}")
        
        # Create input for this update iteration
        update_input = InnerLoopUpdateInput(
            original_task_instruction=updates_input.original_task_instruction,
            last_code=current_code,
            last_rendered_images=current_rendered_images,
            decomposer_output=updates_input.decomposer_output,
            scene_prep_output=updates_input.scene_prep_output,
            iteration=iteration,
            update_folder=update_folder,
            provider=updates_input.provider,
            model=updates_input.model,
            temperature=current_temp,
            layout_verify_iters=updates_input.layout_verify_iters,
            code_fix_iters=updates_input.code_fix_iters
        )
        
        # Run the inner loop update
        try:
            update_output = inner_loop_update(update_input)
            updates_list.append(update_output)
            
            # Check if the reviewer found the layout satisfactory
            if update_output.reviewer_output.satisfactory:
                print(f"{Fore.GREEN}Update iteration {iteration}: Layout deemed satisfactory by reviewer. Stopping early.{Fore.RESET}")
                return UpdatesOutput(
                    final_output=last_successful_output,  # at iter1 this will be None
                    updates=updates_list
                )

            # Check if layout verification was successful
            if (update_output.layout_verification_output is not None and 
                update_output.layout_verification_output.is_success):
                last_successful_output = update_output
                
                # Update current state for next iteration if we have rendered images
                if (update_output.scene_output.render_scene_output is not None and 
                    update_output.scene_output.render_scene_output.rendered_images):
                    current_code = update_output.layout_verification_output.final_code
                    current_rendered_images = update_output.scene_output.render_scene_output.rendered_images
                    print(f"{Fore.GREEN}Update iteration {iteration}: Layout verification successful. Scene generated. Continuing to next iteration.{Fore.RESET}")
                else:
                    print(f"{Fore.YELLOW}Update iteration {iteration}: Layout verification successful but no rendered images. Using previous state.{Fore.RESET}")
            else:
                if not temp_gen:
                    temp_gen = TemperatureIncreaseSchedule()  # only initialize a new one at 0.1 if we need to retry
                print(f"{Fore.YELLOW}Update iteration {iteration}: Layout verification failed. Continuing with previous state.{Fore.RESET}")
                
        except Exception as e:
            print(f"{Fore.RED}Error in update iteration {iteration}: {str(e)}{Fore.RESET}")
            # Continue with next iteration using previous state
            continue
    
    # All iterations completed - return the last successful output or None
    if last_successful_output is not None:
        print(f"{Fore.GREEN}All iterations completed. Returning last successful update.{Fore.RESET}")
        return UpdatesOutput(
            final_output=last_successful_output,
            updates=updates_list
        )
    else:
        print(f"{Fore.YELLOW}All iterations completed with no successful updates. Using original input results.{Fore.RESET}")
        return UpdatesOutput(
            final_output=None,
            updates=updates_list
        )


if __name__ == '__main__':
    from test_data.examples import example_inner_loop_init_output, example_coder_query, example_decomposer_output, example_sceneprep_output
    from pipelines.csp.csp_inner_loop_init import InnerLoopInitInput

    # input_data = InnerLoopUpdateInput(
    #     original_task_instruction=example_coder_query,
    #     last_code=example_inner_loop_init_output.layout_verification_output.final_code,
    #     last_rendered_images=example_inner_loop_init_output.render_output.rendered_images,
    #     decomposer_output=example_decomposer_output,
    #     scene_prep_output=example_sceneprep_output,
    #     iteration=1,
    #     job_folder=Path("exp/test_inner_loop_update1"),
    #     provider="google",
    #     model="gemini-2.5-flash",
    #     temperature=0
    # )
    # output = inner_loop_update(input_data)

    input_data = UpdatesInput(
        original_task_instruction=example_coder_query,
        last_code=example_inner_loop_init_output.layout_verification_output.final_code,
        last_rendered_images=example_inner_loop_init_output.scene_output.render_scene_output.rendered_images,
        decomposer_output=example_decomposer_output,
        scene_prep_output=example_sceneprep_output,
        job_folder=Path("exp/test_inner_loop_updates3"),
        max_iterations=3,
        provider="google",
        model="gemini-2.5-flash",
        temperature=0
    )
    output = updates(input_data)

    from rich import print
    print(output.model_dump())

    # resuming test
    # resume_from = Path("exp/test_inner_loop_updates3")
    # with open(resume_from / "update3" / "code.py", "r") as f:
    #     last_code = f.read()
    # last_images = [
    #     resume_from / "update3" / "renders" / f"update3_render-{axis}.png"
    #     for axis in ['x', 'y', 'z']
    # ]
    # input_data = UpdatesInput(
    #     original_task_instruction=example_coder_query,
    #     last_code=last_code,
    #     last_rendered_images=last_images,
    #     decomposer_output=example_decomposer_output,
    #     scene_prep_output=example_sceneprep_output,
    #     job_folder=Path("exp/test_inner_loop_updates3"),
    #     max_iterations=2,
    #     starting_index=4,
    #     provider="google",
    #     model="gemini-2.5-flash",
    #     temperature=0
    # )
    # output = updates(input_data)

