import sys
import os
sys.path.append(os.getcwd())

from agents import direct_reviewer
from agents.decomposer import DecomposerOutput
from pipelines.common.prep_scene import ScenePrepOutput
from pipelines.common.create_and_render import CreateAndRenderInput, CreateAndRenderOutput, create_and_render
from llms.llms import helper
from pipelines.common.utils import save_pydantic_model_as_pkl

from pydantic import BaseModel, Field
from typing import List, Optional
from pathlib import Path
from colorama import Fore
import json
from yaspin import yaspin


class DirectUpdateInput(BaseModel):
    original_task_instruction: str = Field(..., description="Original task instruction for the scene synthesis")
    last_layout_json_str: str = Field(..., description="Last layout JSON string generated by the direct planner")
    last_rendered_images: List[Path] = Field(..., description="Paths to the rendered images of the layout from different axes (x, y, z)")
    decomposer_output: DecomposerOutput = Field(..., description="Output from the decomposer containing asset list and descriptions")
    scene_prep_output: ScenePrepOutput = Field(..., description="Output from the scene preparation pipeline containing generated model files")
    iteration: int = Field(..., description="Current iteration number of the direct update; only determines file names it saves: update<i>")
    update_folder: Path = Field(..., description="Path to the job folder where the scene will be processed; expected: <job_folder>/update<i>")
    provider: str = Field("google", description="LLM provider to use for the query")
    model: str = Field("gemini-2.5-flash-lite", description="LLM model to use for the query")
    temperature: float = Field(0, description="Temperature for the LLM response generation")

class DirectUpdateOutput(BaseModel):
    reviewer_output: direct_reviewer.DirectReviewerOutput = Field(..., description="Output from the reviewer containing updated layout JSON and satisfaction status")
    scene_output: Optional[CreateAndRenderOutput] = Field(None, description="Output from the scene creation and rendering process (optional, as reviewer might indicate previous layout is satisfactory)")

def direct_update(input_data: DirectUpdateInput) -> DirectUpdateOutput:
    """
    1. Calls the reviewer agent to review last iteration's result
    2. If reviewer indicates satisfactory, return.
    3. Otherwise, obtain the updated layout JSON from reviewer and run the scene creation and rendering pipelines.
    4. Return the outputs of the reviewer and the subsequent pipelines.
    """
    # Ensure the job folder exists
    input_data.update_folder.mkdir(parents=True, exist_ok=True)
    # create a subfolder for pipeline input outputs
    stage_folder = input_data.update_folder / f"stage_update{input_data.iteration}"
    stage_folder.mkdir(parents=True, exist_ok=True)
    staged_files: List[Path] = []

    with yaspin(text=f"Direct Update {input_data.iteration}: Reviewer...", color="green", timer=True) as spinner:
        reviewer_input = direct_reviewer.DirectReviewerInput(
            original_task_instruction=input_data.original_task_instruction,
            layout_json_str=input_data.last_layout_json_str,
            image_paths=input_data.last_rendered_images,
            provider=input_data.provider,
            model=input_data.model,
            temperature=input_data.temperature
        )
        reviewer_output = direct_reviewer.review(reviewer_input)
        staged_files.append(save_pydantic_model_as_pkl(reviewer_output, stage_folder / "reviewer_output.pkl"))
        
        if reviewer_output.satisfactory:
            spinner.ok("✔ Layout Satisfactory")
            return DirectUpdateOutput(
                reviewer_output=reviewer_output,
                scene_output=None
            )
        
        spinner.ok("✔")

    # Save the updated layout JSON to a file
    layout_path = input_data.update_folder / "layout.json"
    try:
        # Parse the JSON string to ensure it's valid and reformat it
        layout_data = json.loads(reviewer_output.updated_layout_json_str)
        with open(layout_path, "w") as f:
            json.dump(layout_data, f, indent=4)
        print(f"{Fore.GREEN}Updated layout JSON saved to {layout_path}{Fore.RESET}")
    except json.JSONDecodeError as e:
        print(f"{Fore.RED}Invalid JSON layout from reviewer: {e}{Fore.RESET}")
        # Save the raw string for debugging
        with open(layout_path, "w") as f:
            f.write(reviewer_output.updated_layout_json_str)
        return DirectUpdateOutput(
            reviewer_output=reviewer_output,
            scene_output=None
        )

    with yaspin(text=f"Direct Update {input_data.iteration}: Creating and Rendering scene according to updated layout...", color="green", timer=True) as spinner:
        create_and_render_input = CreateAndRenderInput(
            layout_path=layout_path,
            scene_prep_output=input_data.scene_prep_output,
            output_blend_path=input_data.update_folder / "scene.blend",
            render_folder=input_data.update_folder / "renders",
            image_prefix=f"update{input_data.iteration}_render"
        )
        create_and_render_output = create_and_render(create_and_render_input)
        staged_files.append(save_pydantic_model_as_pkl(create_and_render_output, stage_folder / "create_and_render_output.pkl"))
        spinner.ok("✔")
    
    update_output = DirectUpdateOutput(
        reviewer_output=reviewer_output,
        scene_output=create_and_render_output
    )

    # remove the stage folder and save the final big output
    final_output_path = input_data.update_folder / f"direct_update_output_{input_data.iteration}.pkl"
    save_pydantic_model_as_pkl(update_output, final_output_path)
    # remove staged pkls
    for staged_file in staged_files:
        if staged_file.exists():
            staged_file.unlink()
    try:
        stage_folder.rmdir()
    except OSError:
        print(f"Warning: Could not remove stage folder {stage_folder}. It might not be empty or does not exist.")

    print(f"{Fore.GREEN}Direct Update {input_data.iteration} completed. Output saved to {final_output_path}{Fore.RESET}")

    return update_output

class TemperatureIncreaseSchedule:
    """Generator to yield temperature values for each iteration."""
    def __init__(self):
        self.temperatures = [0.3, 0.6, 1.2, 1.5]  # after 1.5, hopefully it will have enough randomness to try different solutions
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index < len(self.temperatures):
            temp = self.temperatures[self.index]
            self.index += 1
            return temp
        else:
            return self.temperatures[-1]  # return the last temperature if all have been used

class DirectUpdatesInput(BaseModel):
    # for initializing first update
    original_task_instruction: str = Field(..., description="Original task instruction for the scene synthesis")
    last_layout_json_str: str = Field(..., description="Last layout JSON string generated by the direct planner")
    last_rendered_images: List[Path] = Field(..., description="Paths to the rendered images of the layout from different axes (x, y, z)")
    # constants across updates
    decomposer_output: DecomposerOutput = Field(..., description="Output from the decomposer containing asset list and descriptions")
    scene_prep_output: ScenePrepOutput = Field(..., description="Output from the scene preparation pipeline containing generated model files")
    # update setting
    job_folder: Path = Field(..., description="Path to the job folder where all update subfolders will be created")
    max_iterations: int = Field(3, description="Maximum number of iterations for the direct updates")
    starting_index: int = Field(1, description="Starting index for the update iterations (default: 1)")
    # laosanyang
    provider: str = Field("google", description="LLM provider to use for the query")
    model: str = Field("gemini-2.5-flash-lite", description="LLM model to use for the query")
    temperature: float = Field(0, description="Temperature for the LLM response generation")

class DirectUpdatesOutput(BaseModel):
    final_output: Optional[DirectUpdateOutput] = Field(None, description="Final output of the direct updates, if any updates were run; when None, fall back on input results")
    updates: List[DirectUpdateOutput] = Field([], description="List of all direct update outputs")

def direct_updates(updates_input: DirectUpdatesInput) -> DirectUpdatesOutput:
    """
    Runs the direct updates for the given input.
    In general, 
    - if the input layout is deemed satisfactory by the first update's reviewer, we return an early-terminated signal
    - if an iteration of update output is deemed satisfactory by the subsequent update's reviewer, we return that satisfactory update output and indicate early-stopping
    - if no iterations are satisfactory, we return the last successful update output
    - when no updates were successful, we will have to use the input
    So, in return, we return None when initial result is good or we have done nothing so have to use initial results
    At each step, check the update output first for satisfactory boolean, and then check for successful scene rendering.
    Supports resuming or additional updates; just read last update's layout JSON and prepare image paths for the input model; to continue based on update 3, use starting_index=4 and max_iter as usual (in max_iter=2 case updates 4 and 5 will be run)
    """
    updates_list: List[DirectUpdateOutput] = []
    temp_gen = None
    
    # Initialize variables for tracking current state
    current_layout_json_str = updates_input.last_layout_json_str
    current_rendered_images = updates_input.last_rendered_images
    last_successful_output = None
    
    print(f"{Fore.CYAN}Starting direct updates with max iterations: {updates_input.max_iterations}, starting from index: {updates_input.starting_index}{Fore.RESET}")
    
    for i in range(updates_input.max_iterations):
        iteration = updates_input.starting_index + i
        update_folder = updates_input.job_folder / f"update{iteration}"
        
        # if last update failed scene creation, we need to retry with an increased temperature
        if updates_list and updates_list[-1].scene_output is None and not updates_list[-1].reviewer_output.satisfactory:
            # Get temperature for this iteration - only increase temperature when retrying
            if temp_gen:
                try:
                    current_temp = next(temp_gen)
                except StopIteration:
                    current_temp = 1.5
            else:
                print(f"{Fore.YELLOW}No temperature generator initialized, using last temperature 1.5 for retry.{Fore.RESET}")
                current_temp = 1.5
        else:
            # just use the base temperature
            current_temp = updates_input.temperature
            # reset the temperature generator for the next iteration
            temp_gen = TemperatureIncreaseSchedule()
            
        print(f"{Fore.CYAN}Running update iteration {iteration} with temperature {current_temp}{Fore.RESET}")
        
        # Create input for this update iteration
        update_input = DirectUpdateInput(
            original_task_instruction=updates_input.original_task_instruction,
            last_layout_json_str=current_layout_json_str,
            last_rendered_images=current_rendered_images,
            decomposer_output=updates_input.decomposer_output,
            scene_prep_output=updates_input.scene_prep_output,
            iteration=iteration,
            update_folder=update_folder,
            provider=updates_input.provider,
            model=updates_input.model,
            temperature=current_temp
        )
        
        # Run the direct update
        try:
            update_output = direct_update(update_input)
            updates_list.append(update_output)
            
            # Check if the reviewer found the layout satisfactory
            if update_output.reviewer_output.satisfactory:
                print(f"{Fore.GREEN}Update iteration {iteration}: Layout deemed satisfactory by reviewer. Stopping early.{Fore.RESET}")
                return DirectUpdatesOutput(
                    final_output=last_successful_output,  # at iter1 this will be None
                    updates=updates_list
                )

            # Check if scene creation was successful
            if (update_output.scene_output is not None and 
                update_output.scene_output.render_scene_output is not None and 
                update_output.scene_output.render_scene_output.rendered_images):
                last_successful_output = update_output
                
                # Update current state for next iteration
                current_layout_json_str = update_output.reviewer_output.updated_layout_json_str
                current_rendered_images = update_output.scene_output.render_scene_output.rendered_images
                print(f"{Fore.GREEN}Update iteration {iteration}: Scene creation successful. Continuing to next iteration.{Fore.RESET}")
            else:
                if not temp_gen:
                    temp_gen = TemperatureIncreaseSchedule()  # only initialize a new one if we need to retry
                print(f"{Fore.YELLOW}Update iteration {iteration}: Scene creation failed. Continuing with previous state.{Fore.RESET}")
                
        except Exception as e:
            print(f"{Fore.RED}Error in update iteration {iteration}: {str(e)}{Fore.RESET}")
            # Continue with next iteration using previous state
            continue
    
    # All iterations completed - return the last successful output or None
    if last_successful_output is not None:
        print(f"{Fore.GREEN}All iterations completed. Returning last successful update.{Fore.RESET}")
        return DirectUpdatesOutput(
            final_output=last_successful_output,
            updates=updates_list
        )
    else:
        print(f"{Fore.YELLOW}All iterations completed with no successful updates. Using original input results.{Fore.RESET}")
        return DirectUpdatesOutput(
            final_output=None,
            updates=updates_list
        )


if __name__ == '__main__':
    from test_data.examples import example_scene_desc, example_decomposer_output, example_sceneprep_output, example_layout, example_render_output, example_direct_planner_query
    import json

    # Test single update
    # input_data = DirectUpdateInput(
    #     original_task_instruction=example_scene_desc,
    #     last_layout_json_str=json.dumps(example_layout, indent=4),
    #     last_rendered_images=example_render_output.rendered_images,
    #     decomposer_output=example_decomposer_output,
    #     scene_prep_output=example_sceneprep_output,
    #     iteration=1,
    #     update_folder=Path("exp/test_direct_update1"),
    #     provider="google",
    #     model="gemini-2.5-flash",
    #     temperature=0
    # )
    # output = direct_update(input_data)

    # Test multiple updates
    input_data = DirectUpdatesInput(
        original_task_instruction=example_direct_planner_query,
        last_layout_json_str=json.dumps(example_layout, indent=4),
        last_rendered_images=example_render_output.rendered_images,
        decomposer_output=example_decomposer_output,
        scene_prep_output=example_sceneprep_output,
        job_folder=Path("exp/test_direct_updates3"),
        max_iterations=3,
        provider="google",
        model="gemini-2.5-flash",
        temperature=0
    )
    output = direct_updates(input_data)

    from rich import print
    print(output.model_dump())

    # resuming test
    # resume_from = Path("exp/test_direct_updates3")
    # with open(resume_from / "update3" / "layout.json", "r") as f:
    #     last_layout = json.load(f)
    # last_images = [
    #     resume_from / "update3" / "renders" / f"update3_render-{axis}.png"
    #     for axis in ['x', 'y', 'z']
    # ]
    # input_data = DirectUpdatesInput(
    #     original_task_instruction=example_scene_desc,
    #     last_layout_json_str=json.dumps(last_layout, indent=4),
    #     last_rendered_images=last_images,
    #     decomposer_output=example_decomposer_output,
    #     scene_prep_output=example_sceneprep_output,
    #     job_folder=Path("exp/test_direct_updates3"),
    #     max_iterations=2,
    #     starting_index=4,
    #     provider="google",
    #     model="gemini-2.5-flash",
    #     temperature=0
    # )
    # output = direct_updates(input_data)
